name: CI-CD Pipeline #name of the workflow
#what events trigger workflow, it is represented by the keyword on
on:
    push:
        branches:
            - main
            - 'feature/*' #check the pipeline for faeture branches before pushing to mainss
    pull_request: #a proposal to merge a set of changes from a feature branch into a target branch
        branches:
            - main
    workflow_dispatch:

jobs:
    build-and-push-image:
        runs-on: ubuntu-latest
        steps:
            - name: Checkout code
              uses: actions/checkout@v4 #his action clones your repository into the runner so the workflow can access your code.
            - name: Get changed files
              id: changed-files-build #A unique identifier for this step so its outputs can be referenced in later steps.
              uses: tj-actions/changed-files@v45 #This action detects which files changed in a commit, pull request, or push.
              with:
                files: | #This is a list of files or patterns you want the action to check for changes. The pipe | means multi-line input — you can list multiple file paths or directories.
                    Dockerfile
                    requirements.txt
            #if the Dockerfile or requirements.txt is changed then reuild the docker image
            #github.event_name == 'workflow_dispatch' this is for manual triggering
            - name: Set up Docker Buildx
              if: steps.changed-files-build.outputs.any_changed == 'true' || github.event_name == 'workflow_dispatch'
              uses: docker/setup-buildx-action@v3
            - name: Log in to DockerHub
              if: steps.changed-files-build.outputs.any_changed == 'true' || github.event_name == 'workflow_dispatch'
              uses: docker/login-action@v3
              with:
                username: ${{ vars.DOCKERHUB_USERNAME }}
                password: ${{ secrets.DOCKERHUB_PASSWORD }}
            - name: Build and push Docker image
              if: steps.changed-files-build.outputs.any_changed == 'true' || github.event_name == 'workflow_dispatch' #if there are any changes then only push
              run: |
                docker buildx build --push \
                  --tag ${{ vars.DOCKERHUB_NAMESPACE }}/${{ vars.DOCKERHUB_REPOSITORY }}:latest \
                  --tag ${{ vars.DOCKERHUB_NAMESPACE }}/${{ vars.DOCKERHUB_REPOSITORY }}:${{ github.sha }} \
                  .
              #ensures each image has a unique tag corresponding to the exact commit.
              # . This is the build context — i.e., the current folder contains your Dockerfile and all necessary files for the image.
    unit-and-integration-and-e2e-tests:
      runs-on: ubuntu-latest
      needs: build-and-push-image #defining the dependencies, the build and push should execute first
      env:
        AIRFLOW_WWW_USER_PASSWORD: ${{ secrets.AIRFLOW_WWW_USER_PASSWORD }}
        AIRFLOW_WWW_USER_USERNAME: ${{ secrets.AIRFLOW_WWW_USER_USERNAME }}
        API_KEY: ${{ secrets.API_KEY }}
        CELERY_BACKEND_NAME: ${{ secrets.CELERY_BACKEND_NAME }}
        CELERY_BACKEND_PASSWORD: ${{ secrets.CELERY_BACKEND_PASSWORD }}
        CELERY_BACKEND_USERNAME: ${{ secrets.CELERY_BACKEND_USERNAME }}
        ELT_DATABASE_NAME: ${{ secrets.ELT_DATABASE_NAME }}
        ELT_DATABASE_PASSWORD: ${{ secrets.ELT_DATABASE_PASSWORD }}
        ELT_DATABASE_USERNAME: ${{ secrets.ELT_DATABASE_USERNAME }}
        FERNET_KEY: ${{ secrets.FERNET_KEY }} 
        METADATA_DATABASE_NAME: ${{ secrets.METADATA_DATABASE_NAME }}
        METADATA_DATABASE_PASSWORD: ${{ secrets.METADATA_DATABASE_PASSWORD }}
        METADATA_DATABASE_USERNAME: ${{ secrets.METADATA_DATABASE_USERNAME }}
        POSTGRES_USER: ${{ secrets.POSTGRES_CONN_USERNAME }}
        POSTGRES_PASSWORD: ${{ secrets.POSTGRES_CONN_PASSWORD }}
        POSTGRES_CONN_HOST: ${{ secrets.POSTGRES_CONN_HOST }}
        POSTGRES_CONN_PASSWORD: ${{ secrets.POSTGRES_CONN_PASSWORD }}
        POSTGRES_CONN_PORT: ${{ secrets.POSTGRES_CONN_PORT }}
        POSTGRES_CONN_USERNAME: ${{ secrets.POSTGRES_CONN_USERNAME }}
        AIRFLOW_UID: ${{ vars.AIRFLOW_UID }}
        CHANNEL_HANDLE: ${{ vars.CHANNEL_HANDLE }}
        DOCKERHUB_NAMESPACE: ${{ vars.DOCKERHUB_NAMESPACE }}
        DOCKERHUB_REPOSITORY: ${{ vars.DOCKERHUB_REPOSITORY }}
        DOCKERHUB_USERNAME: ${{ vars.DOCKERHUB_USERNAME }}
      steps:
        - name: Checkout code
          uses: actions/checkout@v4
        - name: Get changed files
          id: changed-files-tests
          uses: tj-actions/changed-files@v45
          with:
            files: |
                dags/**
                include/**
                docker-compose.yaml
        - name: Set up Docker Compose
          if: steps.changed-files-tests.outputs.any_changed == 'true' || github.event_name == 'workflow_dispatch'
          run: docker compose up -d
        - name: Run Unit and Integration Tests
          if: steps.changed-files-tests.outputs.any_changed == 'true' || github.event_name == 'workflow_dispatch'
          run: docker exec -t airflow-worker sh -c "pytest tests/ -v"
        - name: Run End-to-End DAG Tests
          if: steps.changed-files-tests.outputs.any_changed == 'true' || github.event_name == 'workflow_dispatch'
          run: | 
            DAG_NAMES=("produce_json" "update_json" "data_quality")
            for DAG in "${DAG_NAMES[@]}"; do 
              docker exec -t airflow-worker sh -c "airflow dags test $DAG"  
            done
        - name: Tear down Docker Compose
          if: steps.changed-files-tests.outputs.any_changed == 'true' || github.event_name == 'workflow_dispatch'
          run: docker compose down